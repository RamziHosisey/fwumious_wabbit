#![allow(dead_code)]
#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(unused_mut)]
use std::io::Error as IOError;
use std::io::ErrorKind;
use std::error::Error;
use std::env;
use std::process::exit;
use std::fs::File;
use std::io;
use std::io::BufRead;
use std::fmt;
use std::str;
use std::ptr::write;
//use std::io::ErrorKind;
use std::collections::HashMap;
//use std::iter::Peekable;
use fasthash::xx;
use std::time::Instant;


/*
struct Record<'a'> {
    label: i8;
    
}*/


struct VwNamespaceMap {
    num_namespaces: u32,
    map_char_to_index: HashMap <char, u32>,    
    map_name_to_index: HashMap <std::string::String, u32>,
    lookup_char_to_index: [usize; 256]
}

const RECBUF_LEN:usize = 4096 * 2;

/* organization of records buffer 
(offset u16, len u16)[number_of_features]
(u32)[dynamic_number_of_hashes] 
*/

struct RecordsBuffer {
    hashes_buffer: [u32; RECBUF_LEN],
    used: u32,
    len: u32
}

fn get_global_map<'a>() -> Result<VwNamespaceMap, Box<dyn Error>> {
    let mut rdr = csv::ReaderBuilder::new()
        .has_headers(false)
        .from_path("vw_namespace_map.csv")?;
    let mut i: u32 = 0;
    let mut vw = VwNamespaceMap {
                            num_namespaces:0, 
                            map_char_to_index:HashMap::new(),
                            map_name_to_index:HashMap::new(),
                            lookup_char_to_index: [0; 256],
                            };
                            
    for result in rdr.records() {
        let record = result?;
        let char_str = &record[0];
        let name_str = &record[1];
        if char_str.len() != 1 {
            panic!("Can't decode {:?}", record);
        }
        let char = char_str.chars().next().unwrap();
        vw.map_char_to_index.insert(char, i);
        vw.map_name_to_index.insert(String::from(name_str), i);
        vw.lookup_char_to_index[char as usize] = i as usize;
        i += 1;
        
//        println!("{:?}", record);
                
        
    }
    vw.num_namespaces = i;
    Ok(vw)
}

struct RecordReader {
    buffer: io::BufReader<File>,
    vw_map: VwNamespaceMap,
    row: Vec<u8>,
    r_item_out: Vec<u32>
}

enum NextRecordResult {
    Ok,
    End,
    Error,
}

fn next_record(rr: &mut RecordReader) -> NextRecordResult {
        // Output item
//        let mut item_out: Vec<u32> = Vec::with_capacity((self.vw_map.num_namespaces) as usize * 2 *2 + 1);
  //      item_out.resize((self.vw_map.num_namespaces * 2 + 1) as usize, 0);
         
        rr.row.truncate(0);
        rr.buffer.read_until(10, &mut rr.row);
        let rowlen1 = rr.row.len();
        if rowlen1 == 0 {
              return NextRecordResult::End
        }

        let mut bufpos: usize = (rr.vw_map.num_namespaces * 2 + 1) as usize;
        rr.r_item_out.truncate(bufpos);
        for i in &mut rr.r_item_out[0..bufpos] { *i = 0 }     

        unsafe {
        
        let p = rr.row.as_ptr();

        let mut buf = rr.r_item_out.as_mut_ptr();

        match *p.add(0) {
            0x31 => rr.r_item_out[0] = 1,    // 1
            0x2d => rr.r_item_out[0] = 0,    // -1
            _ => return NextRecordResult::Error
        };
        let mut current_char_index:usize = 0;
        let mut i_start:usize;
        let mut i_end:usize = 0;

        while *p.add(i_end) != 0x7c { i_end += 1;};
        i_start = i_end;
        let rowlen = rowlen1 - 1; // ignore last newline byte
        
        while i_end < rowlen {
            while i_end < rowlen && *p.add(i_end) != 0x20 {
                i_end += 1;
            }
//            println!("item out {:?}", std::str::from_utf8(&rr.row[i_start..i_end]));
                            
            if rr.row[i_start] == 0x7c { // "|"
                // As we get new namespace index, we store end of the last one
            //    println!("Closing index {} {}", current_char_index, bufpos);
               write(buf.add(1 + current_char_index*2 + 1), bufpos as u32);
                current_char_index = rr.vw_map.lookup_char_to_index[*p.add(i_start+1) as usize];
             //   println!("Opening index {} {}", current_char_index, bufpos);
                *buf.add(1 + current_char_index*2) = bufpos as u32;
            } else { 
             //   println!("X");
                // We have a feature! Let's hash it and write it to the buffer
         //       println!("item out {:?}", std::str::from_utf8(&rr.row[i_start..i_end]));
                let h = xx::hash32(&rr.row[i_start..i_end]);  
                rr.r_item_out.push(h);
                bufpos += 1;
            }
            
            i_end += 1;
            i_start = i_end ;
            
        }
        *buf.add(1+ current_char_index*2+1) = bufpos as u32;
        }
        
//        println!("item out {:?}", rr.r_item_out);
        return NextRecordResult::Ok
    }


fn read_into_records_buffer(lines: std::io::BufReader<File>, rb: &RecordsBuffer) -> Result<(), Box<dyn Error>> {
    
    

    Ok(())
}


// This is the main function
fn main() -> Result<(), Box<dyn Error>>  {
    // Statements here are executed when the compiled binary is called

    let vw = get_global_map()?;
    let args: Vec<String> = env::args().collect();
    if args.len()<2 {
        println!("Usage: ./hw input_filename");
        exit(1);
    } 
    let input_filename = &args[1];
    let input = File::open(input_filename)?;
    let buffered = io::BufReader::new(input);
/*    for line in buffered.lines() {
        let line2 = line?;
        
    }*/
    
    let num_namespaces = vw.num_namespaces;
    let mut rr = RecordReader{  buffer:buffered, 
                            vw_map: vw,
                            row:  Vec::with_capacity(1024),
                            r_item_out:  Vec::with_capacity(512)
                        };
    rr.r_item_out.resize((num_namespaces * 2 + 1) as usize, 0);

    let now = Instant::now();

    loop {
        let rx = next_record(&mut rr);
        match rx {
            NextRecordResult::End => {break;},
            NextRecordResult::Error => println!("Error from parsing records"),
            NextRecordResult::Ok => ()
        }
    }

    let elapsed = now.elapsed();
    println!("Elapsed: {:.2?}", elapsed);


//    println!("{:?}", args);
  //  println!("{}", input_filename);
    
    // Print text to the console
    //println!("Hello World!");

//    let example: i32 = 1;
    
    Ok(())

}
