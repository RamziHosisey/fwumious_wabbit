use clap::{App, Arg, ArgMatches};

pub fn parse<'a>() -> clap::ArgMatches<'a> {
    
    
  let matches = App::new("superll")
                    .version("1.0")
                    .author("Andraz Tori <atori@outbrain.com>")
                    .about("Superfast Logistic Legression")
                    .arg(Arg::with_name("data")
                     .long("data")
                     .short("d")
                     .value_name("filename")
                     .help("File with input examples")
                     .takes_value(true)
                     .required(true))
                    .arg(Arg::with_name("final_regressor")
                     .long("final_regressor")
                     .short("f")
                     .value_name("filename")
                     .help("Weights file")
                     .takes_value(true))
                    .arg(Arg::with_name("predictions")
                     .short("p")
                     .value_name("output predictions file")
                     .help("Output predictions file")
                     .takes_value(true))
                    .arg(Arg::with_name("cache")
                     .short("c")
                     .long("cache")
                     .help("Use cache file")
                     .takes_value(false))
                    .arg(Arg::with_name("save_resume")
                     .long("save_resume")
                     .help("Save regressor with adaptive counts")
                     .takes_value(false))
                    .arg(Arg::with_name("interactions")
                     .long("interactions")
                     .value_name("namespace,namespace")
                     .help("Adds interactions")
                     .multiple(true)
                     .takes_value(true))
                    .arg(Arg::with_name("keep")
                     .long("keep")
                     .value_name("namespace")
                     .help("Adds single features")
                     .multiple(true)
                     .takes_value(true))
                    .arg(Arg::with_name("learning_rate")
                     .short("l")
                     .long("learning_rate")
                     .value_name("1.0")
                     .help("")
                     .takes_value(true))
                    .arg(Arg::with_name("power_t")
                     .long("power_t")
                     .value_name("0.5")
                     .help("")
                     .takes_value(true))
                    .arg(Arg::with_name("l2")
                     .long("l2")
                     .value_name("0.0")
                     .help("")
                     .takes_value(true))
                    .arg(Arg::with_name("sgd")
                     .long("sgd")
                     .value_name("")
                     .help("")
                     .takes_value(false))
                    .arg(Arg::with_name("adaptive")
                     .long("adaptive")
                     .value_name("")
                     .help("")
                     .takes_value(false))
                    .arg(Arg::with_name("noconstant")
                     .long("noconstant")
                     .value_name("")
                     .help("No intercept")
                     .takes_value(false))
                    .arg(Arg::with_name("link")
                     .long("link")
                     .value_name("logistic")
                     .help("What link function to use")
                     .takes_value(true))
                    .arg(Arg::with_name("loss_function")
                     .long("loss_function")
                     .value_name("logistic")
                     .help("What loss function to use")
                     .takes_value(true))
                    .arg(Arg::with_name("hash_bits")
                     .short("b")
                     .long("hash_bits")
                     .value_name("18")
                     .help("")
                     .takes_value(true))
                    .get_matches();

matches
}